Algorithm used for pathfinding and graph traversal
 A Star  redirects here  For other uses  see A   disambiguation  and Astar  disambiguation  
ClassSearch algorithmData structureGraphWorst case performance
  
    
      
        O
         
        
           
        
        E
        
           
        
        log
          x     
        
           
        
        V
        
           
        
         
         
        O
         
        
          b
          
            d
          
        
         
      
    
      displaystyle O  E  log  V   O b  d   
  
Worst case space complexity
  
    
      
        O
         
        
           
        
        V
        
           
        
         
         
        O
         
        
          b
          
            d
          
        
         
      
    
      displaystyle O  V   O b  d   
  

A   pronounced  A star   is a graph traversal and pathfinding algorithm that is used in many fields of computer science due to its completeness  optimality  and optimal efficiency             Given a weighted graph  a source node and a goal node  the algorithm finds the shortest path  with respect to the given weights  from source to goal 
One major practical drawback is its 
  
    
      
        O
         
        
          b
          
            d
          
        
         
      
    
      displaystyle O b  d   
  
 space complexity where d is the depth of the solution  the length of the shortest path   and b is the branching factor  the maximum number of successors for a state   as it stores all generated nodes in memory  Thus  in practical travel routing systems  it is generally outperformed by algorithms that can pre process the graph to attain better performance             as well as by memory bounded approaches  however  A  is still the best solution in many cases            
Peter Hart  Nils Nilsson and Bertram Raphael of Stanford Research Institute  now SRI International  first published the algorithm in                  It can be seen as an extension of Dijkstra s algorithm  A  achieves better performance by using heuristics to guide its search 
Compared to Dijkstra s algorithm  the A  algorithm only finds the shortest path from a specified source to a specified goal  and not the shortest path tree from a specified source to all possible goals  This is a necessary trade off for using a specific goal directed heuristic  For Dijkstra s algorithm  since the entire shortest path tree is generated  every node is a goal  and there can be no specific goal directed heuristic 


History edit 
A  was invented by researchers working on Shakey the Robot s path planning 
A  was created as part of the Shakey project  which had the aim of building a mobile robot that could plan its own actions  Nils Nilsson originally proposed using the Graph Traverser algorithm            for Shakey s path planning             Graph Traverser is guided by a heuristic function h n   the estimated distance from node n to the goal node  it entirely ignores g n   the distance from the start node to n  Bertram Raphael suggested using the sum  g n    h n              Peter Hart invented the concepts we now call admissibility and consistency of heuristic functions  A  was originally designed for finding least cost paths when the cost of a path is the sum of its  costs  but it has been shown that A  can be used to find optimal paths for any problem satisfying the conditions of a cost algebra            
The original      A  paper            contained a theorem stating that no A  like algorithm     a      could expand fewer nodes than A  if the heuristic function is consistent and A  s tie breaking rule is suitably chosen  A  correction  was published a few years later            claiming that consistency was not required  but this was shown to be false in      in Dechter and Pearl s definitive study of A  s optimality  now called optimal efficiency   which gave an example of A  with a heuristic that was admissible but not consistent expanding arbitrarily more nodes than an alternative A  like algorithm             

Description edit 
A  pathfinding algorithm navigating around a randomly generated maze
Illustration of A  search for finding a path between two points on a graph  From left to right  a heuristic that prefers points closer to the goal is used increasingly  
A  is an informed search algorithm  or a best first search  meaning that it is formulated in terms of weighted graphs  starting from a specific starting node of a graph  it aims to find a path to the given goal node having the smallest cost  least distance travelled  shortest time  etc     It does this by maintaining a tree of paths originating at the start node and extending those paths one edge at a time until the goal node is reached 
At each iteration of its main loop  A  needs to determine which of its paths to extend  It does so based on the cost of the path and an estimate of the cost required to extend the path all the way to the goal  Specifically  A  selects the path that minimizes


  
    
      
        f
         
        n
         
         
        g
         
        n
         
         
        h
         
        n
         
      
    
      displaystyle f n  g n  h n  
  

where n is the next node on the path  g n  is the cost of the path from the start node to n  and h n  is a heuristic function that estimates the cost of the cheapest path from n to the goal  The heuristic function is problem specific  If the heuristic function is admissible   meaning that it never overestimates the actual cost to get to the goal   A  is guaranteed to return a least cost path from start to goal 
Typical implementations of A  use a priority queue to perform the repeated selection of minimum  estimated  cost nodes to expand  This priority queue is known as the open set  fringe or frontier  At each step of the algorithm  the node with the lowest f x  value is removed from the queue  the f and g values of its neighbors are updated accordingly  and these neighbors are added to the queue  The algorithm continues until a removed node  thus the node with the lowest f value out of all fringe nodes  is a goal node      b      The f value of that goal is then also the cost of the shortest path  since h at the goal is zero in an admissible heuristic 
The algorithm described so far only gives the length of the shortest path  To find the actual sequence of steps  the algorithm can be easily revised so that each node on the path keeps track of its predecessor  After this algorithm is run  the ending node will point to its predecessor  and so on  until some node s predecessor is the start node 
As an example  when searching for the shortest route on a map  h x  might represent the straight line distance to the goal  since that is physically the smallest possible distance between any two points  For a grid map from a video game  using the Taxicab distance or the Chebyshev distance becomes better depending on the set of movements available    way or   way  
If the heuristic h satisfies the additional condition h x    d x  y    h y  for every edge  x  y  of the graph  where d denotes the length of that edge   then h is called monotone  or consistent  With a consistent heuristic  A  is guaranteed to find an optimal path without processing any node more than once and A  is equivalent to running Dijkstra s algorithm with the reduced cost d  x  y    d x  y    h y    h x              

Pseudocode edit 
The following pseudocode describes the algorithm 

function reconstruct path cameFrom  current 
    total path     current 
    while current in cameFrom Keys 
        current    cameFrom current 
        total path prepend current 
    return total path

   A  finds a path from start to goal 
   h is the heuristic function  h n  estimates the cost to reach goal from node n 
function A Star start  goal  h 
       The set of discovered nodes that may need to be  re  expanded 
       Initially  only the start node is known 
       This is usually implemented as a min heap or priority queue rather than a hash set 
    openSet     start 

       For node n  cameFrom n  is the node immediately preceding it on the cheapest path from the start
       to n currently known 
    cameFrom    an empty map

       For node n  gScore n  is the currently known cost of the cheapest path from start to n 
    gScore    map with default value of Infinity
    gScore start      

       For node n  fScore n          gScore n    h n   fScore n  represents our current best guess as to
       how cheap a path could be from start to finish if it goes through n 
    fScore    map with default value of Infinity
    fScore start     h start 

    while openSet is not empty
           This operation can occur in O Log N   time if openSet is a min heap or a priority queue
        current    the node in openSet having the lowest fScore   value
        if current   goal
            return reconstruct path cameFrom  current 

        openSet Remove current 
        for each neighbor of current
               d current neighbor  is the weight of the edge from current to neighbor
               tentative gScore is the distance from start to the neighbor through current
            tentative gScore    gScore current    d current  neighbor 
            if tentative gScore  lt  gScore neighbor 
                   This path to neighbor is better than any previous one  Record it 
                cameFrom neighbor     current
                gScore neighbor     tentative gScore
                fScore neighbor     tentative gScore   h neighbor 
                if neighbor not in openSet
                    openSet add neighbor 

       Open set is empty but goal was never reached
    return failure

Remark  In this pseudocode  if a node is reached by one path  removed from openSet  and subsequently reached by a cheaper path  it will be added to openSet again  This is essential to guarantee that the path returned is optimal if the heuristic function is admissible but not  consistent    If the heuristic is consistent  when a node is removed from openSet the path to it is guaranteed to be optimal so the test  tentative gScore  lt  gScore neighbor   will always fail if the node is reached again  The pseudocode implemented here is sometimes called the graph search version of A               This is in contrast with the version without the  tentative gScore  lt  gScore neighbor   test to add nodes back to openSet  which is sometimes called the tree search version of A  and require a consistent heuristic to guarantee optimality 

Illustration of A  search for finding path from a start node to a goal node in a robot motion planning problem  The empty circles represent the nodes in the open set  i e   those that remain to be explored  and the filled ones are in the closed set  Color on each closed node indicates the distance from the goal  the greener  the closer  One can first see the A  moving in a straight line in the direction of the goal  then when hitting the obstacle  it explores alternative routes through the nodes from the open set  See also  Dijkstra s algorithm
Example edit 
An example of an A  algorithm in action where nodes are cities connected with roads and h x  is the     straight line distance to the target point 

Key  green  start  blue  goal  orange  visited
The A  algorithm has real world applications  In this example  edges are railroads and h x  is the great circle distance  the shortest possible distance on a sphere  to the target  The algorithm is searching for a path between Washington  D C   and Los Angeles 


Implementation details edit 
There are a number of simple optimizations or implementation details that can significantly affect the performance of an A  implementation   The first detail to note is that the way the priority queue handles ties can have a significant effect on performance in some situations   If ties are broken so the queue behaves in a LIFO manner  A  will behave like depth first search among equal cost paths  avoiding exploring more than one equally optimal solution  
When a path is required at the end of the search  it is common to keep with each node a reference to that node s parent   At the end of the search  these references can be used to recover the optimal path   If these references are being kept then it can be important that the same node doesn t appear in the priority queue more than once  each entry corresponding to a different path to the node  and each with a different cost    A standard approach here is to check if a node about to be added already appears in the priority queue   If it does  then the priority and parent pointers are changed to correspond to the lower cost path  A standard binary heap based priority queue does not directly support the operation of searching for one of its elements  but it can be augmented with a hash table that maps elements to their position in the heap  allowing this decrease priority operation to be performed in logarithmic time  Alternatively  a Fibonacci heap can perform the same decrease priority operations in constant amortized time 

Special cases edit 
Dijkstra s algorithm  as another example of a uniform cost search algorithm  can be viewed as a special case of A  where        
  
    
      
        h
         
        x
         
         
         
      
    
      displaystyle h x    
  
        for all x                          General depth first search can be implemented using A  by considering that there is a global counter C initialized with a very large value  Every time we process a node we assign C to all of its newly discovered neighbors  After every single assignment  we decrease the counter C by one  Thus the earlier a node is discovered  the higher its        
  
    
      
        h
         
        x
         
      
    
      displaystyle h x  
  
        value  Both Dijkstra s algorithm and depth first search can be implemented more efficiently without including an        
  
    
      
        h
         
        x
         
      
    
      displaystyle h x  
  
        value at each node 

Properties edit 
Termination and completeness edit 
On finite graphs with non negative edge weights A  is guaranteed to terminate and is complete  i e  it will always find a solution  a path from start to goal  if one exists  On infinite graphs with a finite branching factor and edge costs that are bounded away from zero  
  
    
      
        d
         
        x
         
        y
         
         gt 
          x b  
         gt 
         
      
    
      textstyle d x y  gt  varepsilon  gt   
  
 for some fixed 
  
    
      
          x b  
      
    
      displaystyle  varepsilon  
  
   A  is guaranteed to terminate only if there exists a solution            

Admissibility edit 
A search algorithm is said to be admissible if it is guaranteed to return an optimal solution  If the heuristic function used by A  is admissible  then A  is admissible  An intuitive  proof  of this  is as follows 
Call a node closed if it has been visited and is not in the open set   We close a node when we remove it from the open set   A basic property of the A  algorithm  which we ll sketch a proof of below  is that when        
  
    
      
        n
      
    
      displaystyle n 
  
        is closed         
  
    
      
        f
         
        n
         
      
    
      displaystyle f n  
  
        is an optimistic estimate  lower bound  of the true distance from the start to the goal   So when the goal node         
  
    
      
        g
      
    
      displaystyle g 
  
         is closed         
  
    
      
        f
         
        g
         
      
    
      displaystyle f g  
  
        is no more than the true distance   On the other hand  it is no less than the true distance  since it is the length of a path to the goal plus a heuristic term 
Now we ll see that whenever a node        
  
    
      
        n
      
    
      displaystyle n 
  
        is closed         
  
    
      
        f
         
        n
         
      
    
      displaystyle f n  
  
        is an optimistic estimate   It is enough to see that whenever the open set is not empty  it has at least one node        
  
    
      
        n
      
    
      displaystyle n 
  
        on an optimal path to the goal for which        
  
    
      
        g
         
        n
         
      
    
      displaystyle g n  
  
        is the true distance from start  since in that case        
  
    
      
        g
         
        n
         
      
    
      displaystyle g n  
  
                 
  
    
      
        h
         
        n
         
      
    
      displaystyle h n  
  
        underestimates the distance to goal  and therefore so does the smaller value chosen for the closed vertex  Let        
  
    
      
        P
      
    
      displaystyle P 
  
        be an optimal path from the start to the goal   Let        
  
    
      
        p
      
    
      displaystyle p 
  
        be the last closed node on        
  
    
      
        P
      
    
      displaystyle P 
  
        for which        
  
    
      
        g
         
        p
         
      
    
      displaystyle g p  
  
        is the true distance from the start to the goal  the start is one such vertex    The next node in        
  
    
      
        P
      
    
      displaystyle P 
  
        has the correct        
  
    
      
        g
      
    
      displaystyle g 
  
        value  since it was updated when        
  
    
      
        p
      
    
      displaystyle p 
  
        was closed  and it is open since it is not closed 

Optimality and consistency edit 
Algorithm A is optimally efficient with respect to a set of alternative algorithms Alts on a set of problems P if for every problem P in P and every algorithm A  in Alts  the set of nodes expanded by A in solving P is a subset  possibly equal  of the set of nodes expanded by A  in solving P  The definitive study of the optimal efficiency of A  is due to Rina Dechter and Judea Pearl             
They considered a variety of  definitions of Alts and P  in combination with A  s heuristic being merely admissible or being both consistent and admissible   The most interesting positive result they proved is that A   with a consistent heuristic  is optimally efficient with respect to all admissible A  like search algorithms on all  non pathological  search problems   Roughly speaking  their notion of the non pathological problem is what we now mean by  up to tie breaking    This result does not hold if A  s heuristic is admissible but not consistent  In that case  Dechter and Pearl showed there exist admissible A  like algorithms that can expand arbitrarily fewer nodes than A  on some non pathological problems 
Optimal efficiency is about the set of nodes expanded  not the number of node expansions  the number of iterations of A  s main loop    When the heuristic being used is admissible but not consistent  it is possible for a node to be expanded by A  many times  an exponential number of times in the worst case             
In such circumstances  Dijkstra s algorithm could outperform A  by a large margin  However  more recent research found that this pathological case only occurs in certain contrived situations where the edge weight of the search graph is exponential in the size of the graph and that certain inconsistent  but admissible  heuristics can lead to a reduced number of node expansions in A  searches                         

Bounded relaxation edit 
A  search that uses a heuristic that is         times a consistent heuristic  and obtains a suboptimal path
While the admissibility criterion guarantees an optimal solution path  it also means that A  must examine all equally meritorious paths to find the optimal path  To compute approximate shortest paths  it is possible to speed up the search at the expense of optimality by relaxing the admissibility criterion  Oftentimes we want to bound this relaxation  so that we can guarantee that the solution path is no worse than         times the optimal solution path  This new guarantee is referred to as   admissible 
There are a number of   admissible algorithms 

Weighted A  Static Weighting s              If ha n  is an admissible heuristic function  in the weighted version of the A  search one uses hw n      ha n      gt    as the heuristic function  and perform the A  search as usual  which eventually happens faster than using ha since fewer nodes are expanded   The path hence found by the search algorithm can have a cost of at most   times that of the least cost path in the graph             
Convex Upward Downward Parabola  XUP XDP                Modification to the cost function in weighted A  to push optimality toward the start or goal   XDP gives paths which are near optimal close to the start  and XUP paths are near optimal close to the goal  Both yield 
  
    
      
          x f  
      
    
      displaystyle  epsilon  
  
 optimal paths overall 
  
    
      
        
          f
          
            XDP
          
        
         
        n
         
         
        
          
             
            
               
                x f  
            
          
        
         
          xa  
        g
         
        n
         
         
         
         
          x f  
          x     
         
         
         
        
          
             
            g
             
            n
             
              x     
            h
             
            n
             
            
               
              
                 
              
            
             
             
              x f  
            g
             
            n
             
            h
             
            n
             
          
        
          xa  
         
      
    
      displaystyle f   text XDP   n    frac       epsilon      g n     epsilon       sqrt   g n  h n         epsilon g n h n       
  
 
  
    
      
        
          f
          
            XUP
          
        
         
        n
         
         
        
          
             
            
               
                x f  
            
          
        
         
          xa  
        g
         
        n
         
         
        h
         
        n
         
         
        
          
             
            g
             
            n
             
             
            h
             
            n
             
            
               
              
                 
              
            
             
             
              x f  
             
              x f  
              x     
             
             
            h
             
            n
            
               
              
                 
              
            
          
        
          xa  
         
      
    
      displaystyle f   text XUP   n    frac       epsilon      g n  h n    sqrt   g n  h n         epsilon   epsilon    h n           
  
 
Piecewise Upward Downward Curve  pwXU pwXD                Similar to XUP XDP but with piecewise functions instead of parabola  Solution paths are also 
  
    
      
          x f  
      
    
      displaystyle  epsilon  
  
 optimal                                                                               
  
    
      
        
          f
          
            pwXD
          
        
         
        n
         
         
        
          
             
            
              
                
                  g
                   
                  n
                   
                   
                  h
                   
                  n
                   
                   
                
                
                  
                    if  xa  
                  
                  h
                   
                  n
                   
                   gt 
                  g
                   
                  n
                   
                
              
              
                
                  g
                   
                  n
                   
                   
                   
                   
                    x f  
                    x     
                   
                   
                  h
                   
                  n
                   
                  
                     
                  
                    x f  
                   
                
                
                  
                    if  xa  
                  
                  h
                   
                  n
                   
                    x     
                  g
                   
                  n
                   
                
              
            
            
          
        
      
    
      displaystyle f   text pwXD   n    begin cases g n  h n   amp   text if   h n  gt g n   g n     epsilon    h n   epsilon   amp   text if   h n  leq g n  end cases   
  

  
    
      
        
          f
          
            pwXU
          
        
         
        n
         
         
        
          
             
            
              
                
                  g
                   
                  n
                   
                  
                     
                  
                   
                   
                    x f  
                    x     
                   
                   
                   
                  h
                   
                  n
                   
                   
                
                
                  
                    if  xa  
                  
                  g
                   
                  n
                   
                   lt 
                   
                   
                    x f  
                    x     
                   
                   
                  h
                   
                  n
                   
                
              
              
                
                   
                  g
                   
                  n
                   
                   
                  h
                   
                  n
                   
                   
                  
                     
                  
                    x f  
                   
                
                
                  
                    if  xa  
                  
                  g
                   
                  n
                   
                    x     
                   
                   
                    x f  
                    x     
                   
                   
                  h
                   
                  n
                   
                
              
            
            
          
        
      
    
      displaystyle f   text pwXU   n    begin cases g n     epsilon     h n   amp   text if   g n  lt    epsilon    h n    g n  h n    epsilon   amp   text if   g n  geq    epsilon    h n  end cases   
  

Dynamic Weighting             uses the cost function        
  
    
      
        f
         
        n
         
         
        g
         
        n
         
         
         
         
         
          x b  
        w
         
        n
         
         
        h
         
        n
         
      
    
      displaystyle f n  g n      varepsilon w n  h n  
  
         where 
  
    
      
        w
         
        n
         
         
        
          
             
            
              
                
                   
                    x     
                  
                    
                      
                        d
                         
                        n
                         
                      
                      N
                    
                  
                
                
                  d
                   
                  n
                   
                    x     
                  N
                
              
              
                
                   
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
      displaystyle w n    begin cases     frac  d n   N   amp d n  leq N    amp   text otherwise   end cases   
  
  and where        
  
    
      
        d
         
        n
         
      
    
      displaystyle d n  
  
        is the depth of the search and N is the anticipated length of the solution path 
Sampled Dynamic Weighting             uses sampling of nodes to better estimate and debias the heuristic error 

  
    
      
        
          A
          
              x b  
          
          
              x     
          
        
      
    
      displaystyle A   varepsilon       
  
              uses two heuristic functions  The first is the FOCAL list  which is used to select candidate nodes  and the second hF is used to select the most promising node from the FOCAL list 
A              selects nodes with the function        
  
    
      
        A
        f
         
        n
         
         
        B
        
          h
          
            F
          
        
         
        n
         
      
    
      displaystyle Af n  Bh  F  n  
  
         where A and B are constants  If no nodes can be selected  the algorithm will backtrack with the function        
  
    
      
        C
        f
         
        n
         
         
        D
        
          h
          
            F
          
        
         
        n
         
      
    
      displaystyle Cf n  Dh  F  n  
  
         where C and D are constants 
AlphA              attempts to promote depth first exploitation by preferring recently expanded nodes  AlphA  uses the cost function 
  
    
      
        
          f
          
              x b  
          
        
         
        n
         
         
         
         
         
        
          w
          
              x b  
          
        
         
        n
         
         
        f
         
        n
         
      
    
      displaystyle f   alpha   n     w   alpha   n  f n  
  
  where 
  
    
      
        
          w
          
              x b  
          
        
         
        n
         
         
        
          
             
            
              
                
                    x bb 
                
                
                  g
                   
                    x c  
                   
                  n
                   
                   
                    x     
                  g
                   
                  
                    
                      
                        n
                          x e 
                      
                    
                  
                   
                
              
              
                
                    x  b 
                
                
                  
                    otherwise
                  
                
              
            
            
          
        
      
    
      displaystyle w   alpha   n    begin cases  lambda  amp g  pi  n   leq g   tilde  n      Lambda  amp   text otherwise   end cases   
  
  where   and   are constants with 
  
    
      
          x bb 
          x     
          x  b 
      
    
      displaystyle  lambda  leq  Lambda  
  
    n  is the parent of n  and   is the most recently expanded node 
Complexity edit 
As a heuristic search algorithm  the performance of A  is heavily influenced by the quality of the heuristic function 
  
    
      
        h
         
        n
         
      
    
      textstyle h n  
  
  If the heuristic closely approximates the true cost to the goal  A  can significantly reduce the number of node expansions  On the other hand  a poor heuristic can lead to many unnecessary expansions 

Worst Case Scenario edit 
In the worst case  A  expands all nodes 
  
    
      
        n
      
    
      textstyle n 
  
 for which 
  
    
      
        f
         
        n
         
         
        g
         
        n
         
         
        h
         
        n
         
          x     
        
          C
          
              x     
          
        
      
    
      textstyle f n  g n  h n  leq C     
  
  where 
  
    
      
        
          C
          
              x     
          
        
      
    
      textstyle C     
  
 is the cost of the optimal goal node 

Why can t it be worse edit 
Suppose there is a node 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
 in the open list with 
  
    
      
        f
         
        
          N
            x     
        
         
         gt 
        
          C
          
              x     
          
        
      
    
      textstyle f N   gt C     
  
  and it s the next node to be expanded  Since the goal node has 
  
    
      
        f
         
        g
        o
        a
        l
         
         
        g
         
        g
        o
        a
        l
         
         
        h
         
        g
        o
        a
        l
         
         
        g
         
        g
        o
        a
        l
         
         
        
          C
          
              x     
          
        
      
    
      textstyle f goal  g goal  h goal  g goal  C     
  
  and 
  
    
      
        f
         
        
          N
            x     
        
         
         gt 
        
          C
          
              x     
          
        
      
    
      textstyle f N   gt C     
  
  the goal node will have a lower f value and will be expanded before 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
  Therefore  A  never expands nodes with 
  
    
      
        f
         
        n
         
         gt 
        
          C
          
              x     
          
        
      
    
      textstyle f n  gt C     
  
 

Why can t it be better edit 
Assume there exists an optimal algorithm that expands fewer nodes than 
  
    
      
        
          C
          
              x     
          
        
      
    
      textstyle C     
  
 in the worst case using the same heuristic  That means there must be some node 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
 such that 
  
    
      
        f
         
        
          N
            x     
        
         
         lt 
        
          C
          
              x     
          
        
      
    
      textstyle f N   lt C     
  
  yet the algorithm chooses not to expand it 
Now consider a modified graph where a new edge of cost 
  
    
      
          x b  
      
    
      textstyle  varepsilon  
  
  with 
  
    
      
          x b  
         gt 
         
      
    
      textstyle  varepsilon  gt   
  
  is added from 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
 to the goal  If 
  
    
      
        f
         
        
          N
            x     
        
         
         
          x b  
         lt 
        
          C
          
              x     
          
        
      
    
      textstyle f N    varepsilon  lt C     
  
  then the new optimal path goes through 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
  However  since the algorithm still avoids expanding 
  
    
      
        
          N
            x     
        
      
    
      textstyle N  
  
  it will miss the new optimal path  violating its optimality 
Therefore  no optimal algorithm including A  could expand fewer nodes than 
  
    
      
        
          C
          
              x     
          
        
      
    
      textstyle C     
  
 in the worst case 

Mathematical Notation edit 
The worst case complexity of A  is often described as 
  
    
      
        O
         
        
          b
          
            d
          
        
         
      
    
      textstyle O b  d   
  
  where 
  
    
      
        b
      
    
      displaystyle b 
  
 is the branching factor and 
  
    
      
        d
      
    
      textstyle d 
  
 is the depth of the shallowest goal  While this gives a rough intuition  it does not precisely capture the actual behavior of A  
A more accurate bound considers the number of nodes with 
  
    
      
        f
         
        n
         
          x     
        
          C
          
              x     
          
        
      
    
      textstyle f n  leq C     
  
  If 
  
    
      
          x b  
      
    
      displaystyle  varepsilon  
  
 is the smallest possible difference in 
  
    
      
        f
      
    
      textstyle f 
  
 cost between distinct nodes  then A  may expand up to 


  
    
      
        O
        
           
          
            
              
                C
                
                    x     
                
              
                x b  
            
          
           
        
      
    
      displaystyle O left   frac  C       varepsilon    right  
  

This represents both the time and space complexity in the worst case 

Space Complexity edit 
The space complexity of A  is roughly the same as that of all other graph search algorithms  as it keeps all generated nodes in memory             In practice  this turns out to be the biggest drawback of the A  search  leading to the development of memory bounded heuristic searches  such as Iterative deepening A   memory bounded A   and SMA  

Applications edit 
A  is often used for the common pathfinding problem in applications such as video games  but was originally designed as a general graph traversal algorithm            
It finds applications in diverse problems  including the problem of parsing using stochastic grammars in NLP             
Other cases include an Informational search with online learning             

Relations to other algorithms edit 
What sets A  apart from a greedy best first search algorithm is that it takes the cost distance already traveled  g n   into account 
Some common variants of Dijkstra s algorithm can be viewed as a special case of A  where the heuristic 
  
    
      
        h
         
        n
         
         
         
      
    
      displaystyle h n    
  
 for all nodes                          in turn  both Dijkstra and A  are special cases of dynamic programming             
A  itself is a special case of a generalization of branch and bound             
A  is similar to beam search except that beam search maintains a limit on the numbers of paths that it has to explore             

Variants edit 
Anytime A             
Block A 
D 
Field D 
Fringe
Fringe Saving A   FSA  
Generalized Adaptive A   GAA  
Incremental heuristic search
Reduced A             
Iterative deepening A   IDA  
Jump point search
Lifelong Planning A   LPA  
New Bidirectional A   NBA              
Simplified Memory bounded A   SMA  
Theta 
A  can also be adapted to a bidirectional search algorithm  but special care needs to be taken for the stopping criterion             

See also edit 
Any angle path planning  search for paths that are not limited to moving along graph edges but rather can take on any angle
Breadth first search
Depth first search
Dijkstra s algorithm        Algorithm for finding shortest paths
Notes edit 


   A  like  means the algorithm searches by extending paths originating at the start node one edge at a time  just as A  does  This excludes  for example  algorithms that search backward from the goal or in both directions simultaneously  In addition  the algorithms covered by this theorem must be admissible  and  not more informed  than A  

  Goal nodes may be passed over multiple times if there remain other nodes with lower f values  as they may lead to a shorter path to a goal 


References edit 


  a b c Russell  Stuart J   Norvig  Peter         Artificial intelligence a modern approach   th      ed    Boston  Pearson  ISBN                      OCLC                 

  Delling  D   Sanders  P   Schultes  D   Wagner  D           Engineering Route Planning Algorithms   Algorithmics of Large and Complex Networks  Design  Analysis  and Simulation  Lecture Notes in Computer Science  Vol             Springer  pp                doi                              ISBN                        

  Zeng  W   Church  R  L           Finding shortest paths on real road networks  the case for A    International Journal of Geographical Information Science                   Bibcode     IJGIS         Z  doi                            S CID               

  a b c Hart  P  E   Nilsson  N J   Raphael  B           A Formal Basis for the Heuristic Determination of Minimum Cost Paths   IEEE Transactions on Systems Science and Cybernetics                doi         TSSC             

  Doran  J  E   Michie  D                 Experiments with the Graph Traverser program   Proc  R  Soc  Lond  A                       Bibcode     RSPSA         D  doi         rspa            S CID               

  Nilsson  Nils J                The Quest for Artificial Intelligence  PDF   Cambridge  Cambridge University Press  ISBN                     One of the first problems we considered was how to plan a sequence of  way points  that Shakey could use in navigating from place to place      Shakey s navigation problem is a search problem  similar to ones I have mentioned earlier 

  Nilsson  Nils J                The Quest for Artificial Intelligence  PDF   Cambridge  Cambridge University Press  ISBN                     Bertram Raphael  who was directing work on Shakey at that time  observed that a better value for the score would be the sum of the distance traveled so far from the initial position plus my heuristic estimate of how far the robot had to go 

  Edelkamp  Stefan  Jabbar  Shahid  Lluch Lafuente  Alberto          Cost Algebraic Heuristic Search   Proceedings of the Twentieth National Conference on Artificial Intelligence  AAAI   PDF   pp                  ISBN                        

  Hart  Peter E   Nilsson  Nils J   Raphael  Bertram                Correction to  A Formal Basis for the Heuristic Determination of Minimum Cost Paths    PDF   ACM SIGART Bulletin              doi                          S CID              

  a b Dechter  Rina  Judea Pearl          Generalized best first search strategies and the optimality of A    Journal of the ACM                   doi                    S CID              

  Nannicini  Giacomo  Delling  Daniel  Schultes  Dominik  Liberti  Leo          Bidirectional A  search on time dependent road networks   PDF   Networks                   doi         NET       

  Russell  Stuart J   Norvig  Peter         Artificial intelligence  A modern approach   rd      ed    Boston  Pearson  p           ISBN                     

  a b De Smith  Michael John  Goodchild  Michael F   Longley  Paul         Geospatial Analysis  A Comprehensive Guide to Principles  Techniques and Software Tools  Troubadour Publishing Ltd  p            ISBN                    

  a b Hetland  Magnus Lie         Python Algorithms  Mastering Basic Algorithms in the Python Language  Apress  p            ISBN                     archived from the original on    February      

  Martelli  Alberto          On the Complexity of Admissible Search Algorithms   Artificial Intelligence               doi                              

  Felner  Ariel  Uzi Zahavi          Inconsistent heuristics in theory and practice   Artificial Intelligence                         doi         j artint             

  Zhang  Zhifu  N  R  Sturtevant         Using Inconsistent Heuristics on A  Search  Twenty First International Joint Conference on Artificial Intelligence  pp               

  Pohl  Ira          First results on the effect of error in heuristic search   Machine Intelligence    Edinburgh University Press           ISBN                         OCLC                 

  Pearl  Judea         Heuristics  Intelligent Search Strategies for Computer Problem Solving  Addison Wesley  ISBN                        

  Chen  Jingwei  Sturtevant  Nathan R           Conditions for Avoiding Node Re expansions in Bounded Suboptimal Search   Proceedings of the Twenty Eighth International Joint Conference on Artificial Intelligence  International Joint Conferences on Artificial Intelligence Organization            

  Chen  Jingwei  Sturtevant  Nathan R                 Necessary and Sufficient Conditions for Avoiding Reopenings in Best First Suboptimal Search with General Bounding Functions   Proceedings of the AAAI Conference on Artificial Intelligence                     doi         aaai v  i         ISSN                

  Pohl  Ira  August         The avoidance of  relative  catastrophe  heuristic competence  genuine dynamic weighting and computational issues in heuristic problem solving   PDF   Proceedings of the Third International Joint Conference on Artificial Intelligence  IJCAI      Vol          California  USA  pp             

  K ll  Andreas  Hermann Kaindl  August         A new approach to dynamic weighting   Proceedings of the Tenth European Conference on Artificial Intelligence  ECAI      Vienna  Austria  Wiley  pp              ISBN                        

  Pearl  Judea  Jin H  Kim          Studies in semi admissible heuristics   IEEE Transactions on Pattern Analysis and Machine Intelligence                  doi         TPAMI               PMID                S CID              

  Ghallab  Malik  Dennis Allard  August         A    an efficient near admissible heuristic search algorithm   PDF   Proceedings of the Eighth International Joint Conference on Artificial Intelligence  IJCAI      Vol          Karlsruhe  Germany  pp                Archived from the original  PDF  on            

  Reese  Bj rn         AlphA   An   admissible heuristic search algorithm  Report   Institute for Production Technology  University of Southern Denmark  Archived from the original on             Retrieved            

  Klein  Dan  Manning  Christopher D           A  parsing  fast exact Viterbi parse selection   PDF   Proceedings of the      Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics  pp                doi                         

  Kagan E   Ben Gal I           A Group Testing Algorithm with Online Informational Learning   PDF   IIE Transactions                   doi                X              S CID                Archived from the original  PDF  on             Retrieved            

  Ferguson  Dave  Likhachev  Maxim  Stentz  Anthony          A Guide to Heuristic based Path Planning   PDF   Proceedings of the international workshop on planning under uncertainty for autonomous systems  international conference on automated planning and scheduling  ICAPS   pp             Archived  PDF  from the original on            

  Nau  Dana S   Kumar  Vipin  Kanal  Laveen          General branch and bound  and its relation to A  and AO    PDF   Artificial Intelligence                 doi                               Archived  PDF  from the original on            

   Variants of A    theory stanford edu  Retrieved            

  Hansen  Eric A   Zhou  Rong          Anytime Heuristic Search   Journal of Artificial Intelligence Research               arXiv            doi         jair       S CID              

   Fareh  Raouf  Baziyad  Mohammed  Rahman  Mohammad H   Rabie  Tamer  Bettayeb  Maamar                Investigating Reduced Path Planning Strategy for Differential Wheeled Mobile Robot   Robotica                   doi         S                  ISSN                 S CID                

  Pijls  Wim  Post  Henk  Yet another bidirectional algorithm for shortest paths  PDF   Technical report   Econometric Institute  Erasmus University Rotterdam  EI          Archived  PDF  from the original on            

  Goldberg  Andrew V   Harrelson  Chris  Kaplan  Haim  Werneck  Renato F   Efficient Point to Point Shortest Path Algorithms   PDF   Princeton University  Archived  PDF  from the original on    May      


Further reading edit 
Nilsson  N  J          Principles of Artificial Intelligence  Palo Alto  California  Tioga Publishing Company  ISBN                        
External links edit 
Variation on A  called Hierarchical Path Finding A   HPA  
Brian Grinstead   A  Search Algorithm in JavaScript  Updated    Archived from the original on    February       Retrieved   February      
vteGraph and tree traversal algorithmsSearch
    pruning
A 
IDA 
LPA 
SMA 
Best first search
Beam search
Bidirectional search
Breadth first search
Lexicographic
Parallel
B 
Depth first search
Iterative deepening
D 
Fringe search
Jump point search
Monte Carlo tree search
SSS 
Shortest path
Bellman Ford
Dijkstra s
Floyd Warshall
Johnson s
Shortest path faster
Yen s
Minimum spanning tree
Bor vka s
Kruskal s
Prim s
Reverse delete
List of graph search algorithms





Retrieved from  https   en wikipedia org w index php title A  search algorithm amp oldid